---
title: 机器硬件CPU与java内存模型
date: 2019-09-01 09:28:28
categories:
	java
tags:
    [java,多线程]
---

<u>（声明：本文为java高并发编程详解 汪文君 著 的学习笔记，绝大多数来源原书）</u>

# 机器硬件CPU与java内存模型

## 1. 机器硬件CPU

​		计算机中，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及数据的读取和写人操作，CPU所能访问的所有数据只能是计算机的主存(通常是指RAM)，但是CPU与RAM的速度差距巨大，便有了CPU Cache 模型。

### 1.1 CPU cache 模型

​		由于CPU与主存速验证不相等，导致CPU资源受到大量的限制，降低CPU整体的吞吐量，于是就有了在CPU和主内存之间增加缓存的设计，现在缓存的数量都可以增加到3级了，最靠近CPU的缓存称为L1,然后依次是L2, L3和主内存，CPU缓存模型如图所示。

​	{%asset_img Cache与主存访问过速度对比.png%}

​	Cache的出现是为了解决CPU直接访问内存效率低下问题的，程序在运行的过程中，会将运算所需要的数据从主存复制一份到CPU Cache中，这样CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写人，当运算结束之后，再将CPUCache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式CPU Cache替代直接访问主存的方式极大地提高了CPU的吞吐能力，有了CPU Cache之后，整体的CPU主内存(RAM)和主内存之间交互的架构大致如图所示。

{%asset_img CPU通过Cache与主内存进行交互.png%}

### 1.2 CPU 缓存一致性问题

​	在i++这个操作，在程序的运行过程中，首先需要将主内存中的数据复制一份存放到CPU Cache中，那么CPU寄存器在进行数值计算的时候就直接到Cache中读取和写人，当整个过程运算结束之后再将Cache中的数据刷新到主存当中，具体过程如下。
​	1 )读取主内存的i到CPU Cache中。
​	2)对i进行加一-操作。
​	3)将结果写回到CPU Cache中。
​	4)将数据刷新到主内存中。

​	i++在单线程的情况下不会出现任何问题，但是在多线程的情况下就会有问题。如果同时有两个线程执行i++操作,假设i的初始值为0,每一个线程都从主内存中获取i的值存人CPU Cache中，然后经过计算再写人主内存中，很有可能i在经过了两次自增之后结果还是1,这就是典型的缓存不-致性问题。

为了解决缓存不一致性问题，通常主流的解决方法有如下两种。

- 通过总线加锁的方式。

  通过控制总线进行，会阻塞其他cpu对其他组件的访问。

- 通过缓存一致性协议。

  {%asset_img 缓存一致协议.png%}

  当CPU在操作Cache中的数据时，如果发现该变量是-一个共享变量，也就是说在其他的CPU Cache中也存在一-个副本,那么进行如下操作:

  ​    1)读取操作，不做任何处理，只是将Cache中的数据读取到寄存器。
  ​	2)写入操作，发出信号通知其他CPU将该变量的Cacheline置为无效状态，其他CPU在进行该变量读取的时候不得不到主内存中再次获取。

## 2. java内存模型

​		Java的内存模型( Java Memory Mode, JMM)指定了Java 虚拟机如何与计算机的主存( RAM)进行工作，如图所示:

{%asset_img java内存模型.png%}

​	Java的内存模型决定了一个线程对共享变量的写人何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系，具体如下。

* 共享变量存储于主内存之中，每个线程都可以访问。

* 每个线程都有私有的工作内存或者称为本地内存。

* 工作内存只存储该线程对共享变量的副本。

* 线程不能直接操作主内存，只有先操作了工作内存之后才能写人主内存。

* 工作内存和Java内存模型一样也是-一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。

**假设主内存的共享变量为0,线程1和线程2分别拥有共享变量X的副本，假设线程1此时将工作内存中的x修改为1,同时刷新到主内存中，当线程2想要去使用副本x的时候，就会发现该变量已经失效了，必须到主内存中再次获取然后存人自己的工作内容中，这一点和CPU与CPUCache之间的关系非常类似。**



{%asset_img 交互.png%}











































